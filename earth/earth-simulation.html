<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>지구 시뮬레이션 — 공전·자전·대기순환</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#050a18;color:#ccd;font-family:'Segoe UI',system-ui,sans-serif;overflow:hidden;height:100vh}
h1{text-align:center;padding:10px 20px;font-size:1.3em;background:linear-gradient(135deg,#0e1530,#050a18);border-bottom:1px solid #1a2a4a;letter-spacing:1px}
h1 span{color:#5af;font-weight:normal;font-size:.6em;margin-left:8px}

.layout{display:grid;grid-template-columns:1fr 1fr;grid-template-rows:1fr 1fr auto;height:calc(100vh - 50px);gap:2px}
.panel{background:#0a1020;border:1px solid #152040;border-radius:6px;position:relative;overflow:hidden}
.panel-title{position:absolute;top:6px;left:10px;font-size:.72em;color:#4a6a9a;z-index:2;pointer-events:none}

#orbitalPanel{grid-column:1;grid-row:1}
#globePanel{grid-column:2;grid-row:1}
#mapPanel{grid-column:1/3;grid-row:2}

.controls-bar{grid-column:1/3;grid-row:3;background:#0a1020;border:1px solid #152040;border-radius:6px;
  padding:8px 16px;display:flex;align-items:center;gap:12px;flex-wrap:wrap}
.controls-bar label{font-size:.75em;color:#6a7a9a;white-space:nowrap}
.controls-bar input[type=range]{flex:1;min-width:80px;accent-color:#5af;height:5px}
.controls-bar button{background:#152040;border:1px solid #2a3a5a;color:#8ac;padding:4px 12px;border-radius:4px;cursor:pointer;font-size:.78em;transition:.2s}
.controls-bar button:hover{background:#2a3a6a;color:#fff}
.controls-bar button.active{background:#1a4a8a;color:#fff;border-color:#5af}
.controls-bar .sep{width:1px;height:20px;background:#1a2a4a}
.time-display{font-family:'Courier New',monospace;color:#5af;font-size:.85em;min-width:80px;text-align:center}
.info-val{font-family:'Courier New',monospace;color:#fff;font-size:.78em;background:#0d1530;padding:2px 8px;border-radius:3px;border:1px solid #1a2a4a}

canvas{display:block;width:100%;height:100%}
</style>
</head>
<body>
<h1>지구 시뮬레이션<span>공전 · 자전 · 대륙/해양 · 대기순환</span></h1>
<div class="layout">
  <div class="panel" id="orbitalPanel">
    <div class="panel-title">공전 궤도 (Orbital View)</div>
    <canvas id="cvOrbit"></canvas>
  </div>
  <div class="panel" id="globePanel">
    <div class="panel-title">3D 지구 (Globe)</div>
    <canvas id="cvGlobe"></canvas>
  </div>
  <div class="panel" id="mapPanel">
    <div class="panel-title">세계 지도 · 바람 (Wind Map)</div>
    <canvas id="cvMap"></canvas>
  </div>
  <div class="controls-bar">
    <button id="btnPlay" onclick="togglePlay()">▶ 재생</button>
    <div class="sep"></div>
    <label>공전 속도:</label>
    <input type="range" id="sliderOrbSpeed" min="0.1" max="10" step="0.1" value="1" style="max-width:100px">
    <span class="info-val" id="dispOrbSpeed">1.0x</span>
    <div class="sep"></div>
    <label>자전 속도:</label>
    <input type="range" id="sliderRotSpeed" min="0.1" max="30" step="0.1" value="5" style="max-width:100px">
    <span class="info-val" id="dispRotSpeed">5.0x</span>
    <div class="sep"></div>
    <label>날짜:</label>
    <input type="range" id="sliderDay" min="0" max="365" step="1" value="172" style="max-width:120px">
    <span class="info-val" id="dispDay">6월 21일</span>
    <div class="sep"></div>
    <label>황도경사각:</label>
    <input type="range" id="sliderObl" min="21" max="25" step="0.1" value="23.44" style="max-width:100px">
    <span class="info-val" id="dispObl">23.4°</span>
    <div class="sep"></div>
    <label>이심률:</label>
    <input type="range" id="sliderEcc" min="0.0" max="0.06" step="0.001" value="0.017" style="max-width:100px">
    <span class="info-val" id="dispEcc">0.017</span>
    <div class="sep"></div>
    <span class="info-val" id="dispWind" style="min-width:120px">바람: — m/s</span>
  </div>
</div>

<script>
// ===========================
// Continent polygon data [lon, lat]
// ===========================
const CONTINENTS = [
  // Africa
  [[-17,15],[-17,21],[-13,28],[-5,36],[10,37],[11,33],[25,32],[33,30],[35,32],[42,13],[51,12],[50,2],[42,-2],[40,-11],[35,-26],[28,-34],[18,-35],[15,-28],[30,-18],[33,-12],[42,-1],[42,5],[35,10],[30,5],[15,0],[10,5],[-5,5],[-8,5],[-17,10]],
  // Europe
  [[-10,36],[-9,39],[-9,43],[-2,44],[-5,48],[-10,52],[-5,54],[0,52],[5,54],[5,51],[7,54],[10,55],[12,57],[15,55],[19,55],[22,55],[24,60],[28,62],[30,60],[30,55],[28,50],[27,42],[24,38],[26,35],[22,36],[15,38],[13,42],[12,44],[7,44],[5,44],[3,43],[1,41],[-2,40],[-6,37]],
  // Asia (main)
  [[28,62],[32,65],[40,68],[50,70],[60,73],[70,73],[75,72],[85,72],[95,70],[110,68],[120,65],[128,62],[132,56],[135,52],[140,54],[145,50],[142,44],[140,38],[135,35],[130,33],[128,38],[122,38],[120,30],[117,24],[112,22],[110,18],[108,15],[105,10],[104,2],[100,2],[100,13],[98,16],[95,16],[92,22],[88,22],[88,27],[82,28],[80,30],[77,30],[75,33],[74,35],[68,25],[62,25],[56,27],[50,30],[45,33],[40,38],[35,36],[30,33],[28,42],[28,50],[30,55],[30,60]],
  // India
  [[68,25],[70,28],[73,30],[77,30],[80,30],[82,28],[88,27],[88,22],[85,20],[82,16],[80,10],[78,8],[76,12],[73,17]],
  // North America
  [[-168,65],[-162,68],[-155,71],[-140,72],[-130,74],[-110,74],[-95,74],[-85,70],[-80,65],[-65,60],[-58,48],[-66,44],[-70,42],[-72,41],[-75,36],[-82,30],[-82,25],[-90,18],[-92,16],[-95,18],[-100,20],[-105,22],[-110,24],[-115,28],[-118,34],[-122,38],[-124,42],[-124,48],[-130,54],[-140,58],[-150,60],[-160,62]],
  // Central America
  [[-92,16],[-88,16],[-84,14],[-82,10],[-80,8],[-78,8],[-82,10],[-84,11],[-86,12],[-88,14],[-90,14]],
  // South America
  [[-80,10],[-75,12],[-70,12],[-62,10],[-55,5],[-50,2],[-44,-2],[-38,-8],[-35,-12],[-37,-18],[-42,-22],[-48,-26],[-50,-30],[-53,-34],[-58,-38],[-65,-42],[-68,-48],[-70,-54],[-74,-52],[-72,-46],[-73,-40],[-72,-30],[-70,-20],[-75,-14],[-78,-5],[-80,0],[-77,6],[-78,8]],
  // Australia
  [[114,-26],[114,-30],[116,-34],[120,-34],[126,-33],[131,-32],[133,-35],[138,-35],[141,-38],[147,-38],[150,-35],[153,-28],[151,-24],[146,-20],[144,-15],[141,-13],[136,-12],[131,-13],[128,-16],[124,-15],[120,-18],[116,-22]],
  // Indonesia (simplified)
  [[95,6],[98,4],[104,0],[106,-6],[108,-7],[110,-7],[115,-8],[120,-9],[125,-8],[128,-5],[130,-3],[127,0],[122,0],[118,2],[112,2],[108,3],[105,5],[100,6]],
  // Japan (simplified)
  [[130,31],[131,34],[135,35],[137,37],[140,40],[142,43],[144,44],[143,42],[141,39],[139,36],[137,34],[134,34],[132,33]],
  // UK
  [[-6,50],[-5,52],[-3,54],[-5,56],[-5,58],[-3,58],[-1,57],[1,53],[1,51],[-2,50]],
  // Greenland
  [[-55,60],[-50,62],[-45,66],[-42,70],[-25,72],[-18,76],[-18,80],[-28,82],[-45,82],[-55,80],[-58,76],[-56,72],[-52,66]],
  // Antarctica
  [[-180,-65],[-150,-68],[-120,-66],[-90,-70],[-60,-66],[-30,-68],[0,-68],[30,-66],[60,-66],[90,-66],[120,-66],[150,-68],[180,-65],[180,-90],[-180,-90]],
  // New Zealand
  [[166,-47],[168,-45],[172,-42],[175,-40],[178,-38],[178,-40],[176,-42],[172,-44],[170,-46]],
  // Madagascar
  [[44,-12],[46,-16],[48,-20],[48,-24],[47,-26],[44,-24],[43,-20],[43,-15]],
  // Borneo
  [[108,5],[110,3],[112,1],[115,0],[117,1],[118,4],[118,6],[116,7],[112,7],[110,6]],
  // Papua New Guinea
  [[141,-3],[144,-4],[148,-6],[150,-6],[152,-5],[155,-6],[155,-7],[150,-10],[146,-8],[142,-8],[141,-6]],
];

// ===========================
// Land mask (precomputed)
// ===========================
const MASK_W = 720, MASK_H = 360; // 0.5° resolution
let landMask = new Uint8Array(MASK_W * MASK_H);

function pointInPolygon(x, y, poly) {
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i][0], yi = poly[i][1];
    const xj = poly[j][0], yj = poly[j][1];
    if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
      inside = !inside;
    }
  }
  return inside;
}

function buildLandMask() {
  for (let row = 0; row < MASK_H; row++) {
    const lat = 90 - row * (180 / MASK_H);
    for (let col = 0; col < MASK_W; col++) {
      const lon = -180 + col * (360 / MASK_W);
      for (const poly of CONTINENTS) {
        if (pointInPolygon(lon, lat, poly)) {
          landMask[row * MASK_W + col] = 1;
          break;
        }
      }
    }
  }
}

function isLand(lat, lon) {
  lon = ((lon % 360) + 540) % 360 - 180;
  const col = Math.floor((lon + 180) / 360 * MASK_W);
  const row = Math.floor((90 - lat) / 180 * MASK_H);
  if (row < 0 || row >= MASK_H || col < 0 || col >= MASK_W) return false;
  return landMask[row * MASK_W + col] === 1;
}

// ===========================
// Wind model
// ===========================
function getWind(lat, lon, dayOfYear, obliquityDeg) {
  const oblRad = obliquityDeg * Math.PI / 180;
  // Solar declination
  const decl = obliquityDeg * Math.sin(2 * Math.PI * (dayOfYear - 80) / 365);
  // ITCZ latitude shifts with declination
  const itcz = decl * 0.6;
  const latR = lat - itcz;
  const absLatR = Math.abs(latR);
  const signLat = lat >= 0 ? 1 : -1;
  const signLatR = latR >= 0 ? 1 : -1;

  let u = 0, v = 0; // u=zonal(+east), v=meridional(+north)

  if (absLatR < 30) {
    // Hadley cell: trade winds
    const t = absLatR / 30;
    const strength = Math.sin(Math.PI * t) * 7;
    u = -strength * 0.8; // easterly
    v = -signLatR * strength * 0.35; // toward ITCZ
    // Coriolis deflection
    u -= signLat * strength * 0.25;
  } else if (absLatR < 60) {
    // Ferrel cell: westerlies
    const t = (absLatR - 30) / 30;
    const strength = Math.sin(Math.PI * t) * 10;
    u = strength * 0.9; // westerly
    v = signLatR * strength * 0.1;
    u += signLat * strength * 0.15;
  } else {
    // Polar cell: polar easterlies
    const t = (absLatR - 60) / 30;
    const strength = Math.sin(Math.PI * t) * 5;
    u = -strength * 0.7;
    v = -signLatR * strength * 0.3;
  }

  // Land heating effect (simplified monsoon)
  const land = isLand(lat, lon);
  const summer = (lat >= 0) ? (dayOfYear > 80 && dayOfYear < 265) : (dayOfYear < 80 || dayOfYear > 265);
  if (land && summer && Math.abs(lat) > 10 && Math.abs(lat) < 40) {
    // Low pressure over land in summer -> onshore flow
    v += signLat * 2.5;
    u *= 0.7;
  }

  // Jet stream at ~30° and ~60°
  const absLat = Math.abs(lat);
  if (absLat > 28 && absLat < 35) {
    const jet = Math.exp(-((absLat - 31) ** 2) / 4) * 4;
    u += jet;
  }
  if (absLat > 55 && absLat < 65) {
    const jet = Math.exp(-((absLat - 60) ** 2) / 8) * 3;
    u += jet;
  }

  // Orographic and longitudinal variation (subtle)
  u += Math.sin(lon * Math.PI / 60) * 0.8;
  v += Math.cos(lon * Math.PI / 90) * 0.5;

  return { u, v };
}

// ===========================
// Wind particles
// ===========================
const NUM_PARTICLES = 3000;
let particles = [];
function initParticles() {
  particles = [];
  for (let i = 0; i < NUM_PARTICLES; i++) {
    particles.push(randomParticle());
  }
}
function randomParticle() {
  return {
    lat: (Math.random() - 0.5) * 170,
    lon: Math.random() * 360 - 180,
    age: Math.floor(Math.random() * 80),
    maxAge: 60 + Math.floor(Math.random() * 60),
    prevLat: 0, prevLon: 0,
  };
}
function updateParticles(dayOfYear, obliquity, dt) {
  for (const p of particles) {
    p.prevLat = p.lat;
    p.prevLon = p.lon;
    const w = getWind(p.lat, p.lon, dayOfYear, obliquity);
    // Convert m/s to degrees/step (approx)
    const scale = dt * 0.15;
    p.lon += w.u * scale / Math.max(Math.cos(p.lat * Math.PI / 180), 0.1);
    p.lat += w.v * scale;
    p.age++;
    // Wrap longitude
    if (p.lon > 180) p.lon -= 360;
    if (p.lon < -180) p.lon += 360;
    // Clamp latitude
    if (p.lat > 85) p.lat = 85;
    if (p.lat < -85) p.lat = -85;
    // Reset old particles
    if (p.age > p.maxAge) {
      Object.assign(p, randomParticle());
      p.age = 0;
    }
  }
}

// ===========================
// Canvas setup
// ===========================
function setupCanvas(canvas) {
  const rect = canvas.parentElement.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return { ctx, w: rect.width, h: rect.height, dpr };
}

// ===========================
// Globe rendering
// ===========================
const GLOBE_RES = 2; // pixel step (lower = sharper but slower)
// Color palettes for land elevation and ocean depth (simplified)
const OCEAN_DEEP = [10, 30, 80];
const OCEAN_SHALLOW = [20, 70, 140];
const LAND_LOW = [34, 110, 34];
const LAND_HIGH = [120, 100, 50];
const ICE = [220, 230, 240];

function getTerrainColor(lat, lon, land) {
  const absLat = Math.abs(lat);
  if (absLat > 75) return ICE;
  if (!land) {
    // Depth variation
    const d = (Math.sin(lon * 0.1) * 0.3 + Math.cos(lat * 0.15) * 0.3 + 0.5);
    return [
      OCEAN_DEEP[0] + (OCEAN_SHALLOW[0] - OCEAN_DEEP[0]) * d,
      OCEAN_DEEP[1] + (OCEAN_SHALLOW[1] - OCEAN_DEEP[1]) * d,
      OCEAN_DEEP[2] + (OCEAN_SHALLOW[2] - OCEAN_DEEP[2]) * d,
    ];
  }
  // Land: latitude-based biome
  if (absLat > 65) return [180, 200, 190]; // tundra
  if (absLat > 50) return [50, 100, 40]; // boreal
  if (absLat < 10) return [20, 90, 20]; // tropical
  if (absLat < 30) {
    // Desert belt (simplified)
    const dryness = Math.cos(lon * Math.PI / 40) * 0.5 + 0.5;
    if (dryness > 0.6) return [160, 140, 80]; // desert
    return [80, 130, 40]; // savanna
  }
  return LAND_LOW; // temperate
}

function renderGlobe(ctx, w, h, rotLon, obliquityDeg, dayOfYear) {
  const cx = w / 2, cy = h / 2;
  const R = Math.min(w, h) * 0.42;
  const oblRad = obliquityDeg * Math.PI / 180;
  // Seasonal tilt direction
  const seasonAngle = 2 * Math.PI * (dayOfYear - 172) / 365;
  const tiltX = oblRad * Math.cos(seasonAngle);
  const tiltZ = oblRad * Math.sin(seasonAngle);
  const cosTilt = Math.cos(tiltX);
  const sinTilt = Math.sin(tiltX);

  // Sun direction for lighting
  const sunDir = { x: Math.sin(seasonAngle) * 0.3, y: -0.2, z: 1 };
  const sunLen = Math.sqrt(sunDir.x ** 2 + sunDir.y ** 2 + sunDir.z ** 2);
  sunDir.x /= sunLen; sunDir.y /= sunLen; sunDir.z /= sunLen;

  const imgData = ctx.getImageData(0, 0, w * (window.devicePixelRatio || 1), h * (window.devicePixelRatio || 1));
  const dpr = window.devicePixelRatio || 1;

  for (let sy = 0; sy < h; sy += GLOBE_RES) {
    for (let sx = 0; sx < w; sx += GLOBE_RES) {
      const dx = sx - cx, dy = sy - cy;
      const distSq = dx * dx + dy * dy;
      if (distSq > R * R) continue;

      const x = dx / R;
      const yp = dy / R;
      const zp = Math.sqrt(Math.max(0, 1 - x * x - yp * yp));

      // Inverse tilt rotation (around X axis)
      const y = -yp * cosTilt + zp * sinTilt;
      const z = yp * sinTilt + zp * cosTilt;

      const lat = Math.asin(Math.max(-1, Math.min(1, y))) * 180 / Math.PI;
      let lon = Math.atan2(x, z) * 180 / Math.PI + rotLon;
      lon = ((lon % 360) + 540) % 360 - 180;

      const land = isLand(lat, lon);
      const baseColor = getTerrainColor(lat, lon, land);

      // Lighting
      const nx = x, ny = -yp, nz = zp;
      let light = nx * sunDir.x + ny * sunDir.y + nz * sunDir.z;
      light = Math.max(0.15, light);
      // Atmosphere edge glow
      const edge = 1 - Math.sqrt(distSq) / R;
      const atmo = Math.pow(1 - edge, 3) * 0.4;

      const r = Math.min(255, baseColor[0] * light + atmo * 60);
      const g = Math.min(255, baseColor[1] * light + atmo * 100);
      const b = Math.min(255, baseColor[2] * light + atmo * 180);

      // Fill pixels
      for (let py = 0; py < GLOBE_RES * dpr && (sy * dpr + py) < imgData.height; py++) {
        for (let px = 0; px < GLOBE_RES * dpr && (sx * dpr + px) < imgData.width; px++) {
          const idx = ((sy * dpr + py) * imgData.width + (sx * dpr + px)) * 4;
          imgData.data[idx] = r;
          imgData.data[idx + 1] = g;
          imgData.data[idx + 2] = b;
          imgData.data[idx + 3] = 255;
        }
      }
    }
  }
  ctx.putImageData(imgData, 0, 0);

  // Atmosphere ring
  const grad = ctx.createRadialGradient(cx, cy, R - 3, cx, cy, R + 12);
  grad.addColorStop(0, 'rgba(100,160,255,0.2)');
  grad.addColorStop(0.5, 'rgba(80,140,255,0.08)');
  grad.addColorStop(1, 'transparent');
  ctx.beginPath();
  ctx.arc(cx, cy, R + 12, 0, Math.PI * 2);
  ctx.fillStyle = grad;
  ctx.fill();

  // Axis line
  const axTopX = cx - R * 1.3 * Math.sin(tiltX);
  const axTopY = cy - R * 1.3 * Math.cos(tiltX);
  const axBotX = cx + R * 1.3 * Math.sin(tiltX);
  const axBotY = cy + R * 1.3 * Math.cos(tiltX);
  ctx.beginPath();
  ctx.moveTo(axBotX, axBotY);
  ctx.lineTo(axTopX, axTopY);
  ctx.strokeStyle = 'rgba(78,205,196,0.7)';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  // Arrow
  const aAngle = Math.atan2(axTopY - cy, axTopX - cx);
  ctx.beginPath();
  ctx.moveTo(axTopX, axTopY);
  ctx.lineTo(axTopX - 7 * Math.cos(aAngle - 0.4), axTopY - 7 * Math.sin(aAngle - 0.4));
  ctx.moveTo(axTopX, axTopY);
  ctx.lineTo(axTopX - 7 * Math.cos(aAngle + 0.4), axTopY - 7 * Math.sin(aAngle + 0.4));
  ctx.stroke();

  // Wind particles on globe
  ctx.globalAlpha = 0.8;
  for (const p of particles) {
    if (p.age < 2) continue;
    const latRad = p.lat * Math.PI / 180;
    const lonRad = (p.lon - rotLon) * Math.PI / 180;

    const px3 = Math.cos(latRad) * Math.sin(lonRad);
    const py3 = Math.sin(latRad);
    const pz3 = Math.cos(latRad) * Math.cos(lonRad);

    // Apply tilt
    const pyTilt = -(py3 * cosTilt - pz3 * sinTilt);
    const pzTilt = py3 * sinTilt + pz3 * cosTilt;

    if (pzTilt < 0.05) continue; // behind globe

    const screenX = cx + px3 * R;
    const screenY = cy + pyTilt * R;

    // Previous position
    const plRad = p.prevLat * Math.PI / 180;
    const plnRad = (p.prevLon - rotLon) * Math.PI / 180;
    const ppx = Math.cos(plRad) * Math.sin(plnRad);
    const ppy = Math.sin(plRad);
    const ppz = Math.cos(plRad) * Math.cos(plnRad);
    const ppyT = -(ppy * cosTilt - ppz * sinTilt);
    const ppzT = ppy * sinTilt + ppz * cosTilt;
    if (ppzT < 0.05) continue;
    const sPX = cx + ppx * R;
    const sPY = cy + ppyT * R;

    const w = getWind(p.lat, p.lon, dayOfYear, obliquityDeg);
    const speed = Math.sqrt(w.u ** 2 + w.v ** 2);
    const alpha = Math.min(1, (p.age / p.maxAge < 0.1 ? p.age / p.maxAge * 10 : p.age / p.maxAge > 0.8 ? (1 - p.age / p.maxAge) * 5 : 1)) * pzTilt * 0.7;

    ctx.beginPath();
    ctx.moveTo(sPX, sPY);
    ctx.lineTo(screenX, screenY);
    const hue = speed < 5 ? 200 : speed < 8 ? 60 : 0;
    ctx.strokeStyle = `hsla(${hue},80%,70%,${alpha})`;
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Info text
  ctx.fillStyle = '#4a6a9a';
  ctx.font = '11px Courier New';
  ctx.textAlign = 'right';
  ctx.fillText(`자전축 기울기: ${obliquityDeg.toFixed(1)}°`, w - 10, h - 10);
}

// ===========================
// Orbital view
// ===========================
function renderOrbital(ctx, w, h, orbitalAngle, ecc, obliquityDeg, dayOfYear) {
  ctx.clearRect(0, 0, w, h);

  const cx = w / 2, cy = h / 2;
  const orbitA = Math.min(w, h) * 0.38;
  const orbitB = orbitA * Math.sqrt(1 - ecc * ecc);
  const focusOffset = ecc * orbitA;

  // Stars
  let rng = 77;
  function rand() { rng = (rng * 16807) % 2147483647; return rng / 2147483647; }
  ctx.fillStyle = '#ffffff';
  for (let i = 0; i < 60; i++) {
    ctx.globalAlpha = 0.2 + rand() * 0.4;
    ctx.beginPath();
    ctx.arc(rand() * w, rand() * h, rand() * 1, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Orbit path
  ctx.beginPath();
  ctx.ellipse(cx + focusOffset, cy, orbitA, orbitB, 0, 0, Math.PI * 2);
  ctx.strokeStyle = '#1a2a4a';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 6]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Season labels
  const seasons = [
    { angle: 0, label: '춘분 (3월)' },
    { angle: Math.PI / 2, label: '하지 (6월)' },
    { angle: Math.PI, label: '추분 (9월)' },
    { angle: 3 * Math.PI / 2, label: '동지 (12월)' },
  ];
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  for (const s of seasons) {
    const sx = cx + focusOffset + orbitA * Math.cos(s.angle) * 1.12;
    const sy = cy + orbitB * Math.sin(s.angle) * 1.15;
    ctx.fillStyle = '#3a5a8a';
    ctx.fillText(s.label, sx, sy);
  }

  // Sun
  const sunGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 25);
  sunGrad.addColorStop(0, '#ffffdd');
  sunGrad.addColorStop(0.3, '#ffcc33');
  sunGrad.addColorStop(0.7, '#ff8800');
  sunGrad.addColorStop(1, 'transparent');
  ctx.beginPath();
  ctx.arc(cx, cy, 25, 0, Math.PI * 2);
  ctx.fillStyle = sunGrad;
  ctx.fill();
  ctx.beginPath();
  ctx.arc(cx, cy, 8, 0, Math.PI * 2);
  ctx.fillStyle = '#fff';
  ctx.fill();
  ctx.fillStyle = '#6a5a2a';
  ctx.font = '9px sans-serif';
  ctx.fillText('태양', cx, cy + 20);

  // Earth position
  const eX = cx + focusOffset + orbitA * Math.cos(orbitalAngle);
  const eY = cy + orbitB * Math.sin(orbitalAngle);

  // Earth
  const eR = 12;
  const earthGrad = ctx.createRadialGradient(eX - 2, eY - 2, 1, eX, eY, eR);
  earthGrad.addColorStop(0, '#5599dd');
  earthGrad.addColorStop(0.7, '#2266aa');
  earthGrad.addColorStop(1, '#0a3366');
  ctx.beginPath();
  ctx.arc(eX, eY, eR, 0, Math.PI * 2);
  ctx.fillStyle = earthGrad;
  ctx.fill();

  // Axial tilt indicator on Earth
  const oblRad = obliquityDeg * Math.PI / 180;
  const tiltDir = orbitalAngle + Math.PI / 2;
  const axLen = eR * 2.5;
  const axX = Math.sin(oblRad) * Math.cos(tiltDir);
  const axY = Math.sin(oblRad) * Math.sin(tiltDir);
  ctx.beginPath();
  ctx.moveTo(eX - axX * axLen * 0.3, eY + axLen * 0.7);
  ctx.lineTo(eX + axX * axLen * 0.3, eY - axLen * 0.7);
  ctx.strokeStyle = '#4ecdc4';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Sun rays
  ctx.strokeStyle = 'rgba(255,200,50,0.15)';
  ctx.lineWidth = 1;
  for (let i = 0; i < 12; i++) {
    const a = i * Math.PI / 6;
    ctx.beginPath();
    ctx.moveTo(cx + 12 * Math.cos(a), cy + 12 * Math.sin(a));
    ctx.lineTo(cx + 35 * Math.cos(a), cy + 35 * Math.sin(a));
    ctx.stroke();
  }

  // Perihelion/Aphelion markers
  ctx.fillStyle = '#3a5a8a';
  ctx.font = '9px sans-serif';
  const periX = cx + focusOffset + orbitA;
  ctx.fillText('근일점', periX, cy + 14);
  const apoX = cx + focusOffset - orbitA;
  ctx.fillText('원일점', apoX, cy + 14);

  // Distance
  const dist = Math.sqrt((eX - cx) ** 2 + (eY - cy) ** 2);
  const au = (1 - ecc * Math.cos(orbitalAngle)).toFixed(4);
  ctx.fillStyle = '#5a7aaa';
  ctx.font = '10px Courier New';
  ctx.textAlign = 'left';
  ctx.fillText(`거리: ${au} AU`, 10, h - 24);
  ctx.fillText(`이심률: ${ecc.toFixed(4)}`, 10, h - 10);

  // Earth label
  ctx.fillStyle = '#5af';
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('지구', eX, eY + eR + 12);
}

// ===========================
// Map rendering
// ===========================
let mapTexture = null;
function renderMapTexture(ctx, w, h) {
  // Pre-render continent outlines
  const offscreen = document.createElement('canvas');
  offscreen.width = w;
  offscreen.height = h;
  const oc = offscreen.getContext('2d');

  // Ocean gradient
  const oceanGrad = oc.createLinearGradient(0, 0, 0, h);
  oceanGrad.addColorStop(0, '#0a2040');
  oceanGrad.addColorStop(0.3, '#0c2855');
  oceanGrad.addColorStop(0.5, '#0e3060');
  oceanGrad.addColorStop(0.7, '#0c2855');
  oceanGrad.addColorStop(1, '#0a2040');
  oc.fillStyle = oceanGrad;
  oc.fillRect(0, 0, w, h);

  // Draw continents
  for (const poly of CONTINENTS) {
    oc.beginPath();
    for (let i = 0; i < poly.length; i++) {
      const x = (poly[i][0] + 180) / 360 * w;
      const y = (90 - poly[i][1]) / 180 * h;
      if (i === 0) oc.moveTo(x, y);
      else oc.lineTo(x, y);
    }
    oc.closePath();
    // Determine color based on average latitude
    const avgLat = poly.reduce((s, p) => s + Math.abs(p[1]), 0) / poly.length;
    if (avgLat > 70) oc.fillStyle = '#c8d8d8';
    else if (avgLat > 55) oc.fillStyle = '#2a5a2a';
    else if (avgLat < 12) oc.fillStyle = '#1a6a20';
    else oc.fillStyle = '#2a6a28';
    oc.fill();
    oc.strokeStyle = '#1a4a2a';
    oc.lineWidth = 0.5;
    oc.stroke();
  }

  // Grid lines
  oc.strokeStyle = '#ffffff10';
  oc.lineWidth = 0.5;
  for (let lat = -60; lat <= 60; lat += 30) {
    const y = (90 - lat) / 180 * h;
    oc.beginPath();
    oc.moveTo(0, y);
    oc.lineTo(w, y);
    oc.stroke();
  }
  for (let lon = -120; lon <= 120; lon += 60) {
    const x = (lon + 180) / 360 * w;
    oc.beginPath();
    oc.moveTo(x, 0);
    oc.lineTo(x, h);
    oc.stroke();
  }

  // Latitude labels
  oc.fillStyle = '#3a5a7a';
  oc.font = '9px sans-serif';
  oc.textAlign = 'right';
  for (const lat of [60, 30, 0, -30, -60]) {
    const y = (90 - lat) / 180 * h;
    oc.fillText(`${lat}°`, 22, y + 3);
  }

  mapTexture = offscreen;
}

function renderMap(ctx, w, h, dayOfYear, obliquity) {
  if (!mapTexture || mapTexture.width !== Math.round(w) || mapTexture.height !== Math.round(h)) {
    const tex = document.createElement('canvas');
    tex.width = Math.round(w);
    tex.height = Math.round(h);
    renderMapTexture(tex.getContext('2d'), Math.round(w), Math.round(h));
    mapTexture = tex;
  }
  ctx.drawImage(mapTexture, 0, 0, w, h);

  // ITCZ line
  const decl = obliquity * Math.sin(2 * Math.PI * (dayOfYear - 80) / 365);
  const itczLat = decl * 0.6;
  const itczY = (90 - itczLat) / 180 * h;
  ctx.beginPath();
  ctx.moveTo(0, itczY);
  ctx.setLineDash([6, 4]);
  ctx.lineTo(w, itczY);
  ctx.strokeStyle = 'rgba(255,100,100,0.5)';
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#ff6b6b88';
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('ITCZ', w - 34, itczY - 3);

  // Circulation cell labels
  ctx.fillStyle = '#ffffff30';
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'center';
  const labelX = w - 55;
  const cells = [
    { lat: 75, name: '극순환' },
    { lat: 45, name: '페렐순환' },
    { lat: 15, name: '해들리순환' },
    { lat: -15, name: '해들리순환' },
    { lat: -45, name: '페렐순환' },
    { lat: -75, name: '극순환' },
  ];
  for (const c of cells) {
    const y = (90 - c.lat) / 180 * h;
    ctx.fillText(c.name, labelX, y);
  }

  // Wind direction labels
  ctx.fillStyle = '#ffffff20';
  const windLabels = [
    { lat: 75, name: '극동풍' },
    { lat: 50, name: '편서풍' },
    { lat: 20, name: '무역풍(NE)' },
    { lat: -20, name: '무역풍(SE)' },
    { lat: -50, name: '편서풍' },
    { lat: -75, name: '극동풍' },
  ];
  ctx.textAlign = 'left';
  for (const wl of windLabels) {
    const y = (90 - wl.lat) / 180 * h;
    ctx.fillText(wl.name, 28, y);
  }

  // Wind particles
  for (const p of particles) {
    if (p.age < 2) continue;
    const x = (p.lon + 180) / 360 * w;
    const y = (90 - p.lat) / 180 * h;
    const px = (p.prevLon + 180) / 360 * w;
    const py = (90 - p.prevLat) / 180 * h;

    // Skip if wrapping around
    if (Math.abs(x - px) > w * 0.3) continue;

    const wind = getWind(p.lat, p.lon, dayOfYear, obliquity);
    const speed = Math.sqrt(wind.u ** 2 + wind.v ** 2);
    const life = p.age / p.maxAge;
    const alpha = Math.min(1, life < 0.1 ? life * 10 : life > 0.8 ? (1 - life) * 5 : 1) * 0.8;

    const hue = speed < 4 ? 210 : speed < 7 ? 60 : speed < 10 ? 30 : 0;
    const lightness = 50 + speed * 2;

    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(x, y);
    ctx.strokeStyle = `hsla(${hue},80%,${lightness}%,${alpha})`;
    ctx.lineWidth = speed > 8 ? 1.5 : 1;
    ctx.stroke();
  }

  // Wind speed legend
  ctx.fillStyle = '#3a5a7a';
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('풍속:', 6, h - 6);
  const legendColors = [
    { speed: '< 4', color: 'hsl(210,80%,55%)' },
    { speed: '4-7', color: 'hsl(60,80%,55%)' },
    { speed: '7-10', color: 'hsl(30,80%,55%)' },
    { speed: '> 10', color: 'hsl(0,80%,55%)' },
  ];
  let lx = 32;
  for (const lc of legendColors) {
    ctx.fillStyle = lc.color;
    ctx.fillRect(lx, h - 12, 12, 6);
    ctx.fillStyle = '#6a8aaa';
    ctx.fillText(lc.speed, lx + 14, h - 6);
    lx += 46;
  }
  ctx.fillStyle = '#5a7a9a';
  ctx.fillText('m/s', lx, h - 6);
}

// ===========================
// State & Animation
// ===========================
let playing = true;
let orbitalAngle = -Math.PI / 2 + (172 / 365) * 2 * Math.PI; // start at summer solstice
let rotLon = 0;
let lastTime = 0;

const elSliderDay = document.getElementById('sliderDay');
const elSliderObl = document.getElementById('sliderObl');
const elSliderEcc = document.getElementById('sliderEcc');
const elSliderOrbSpeed = document.getElementById('sliderOrbSpeed');
const elSliderRotSpeed = document.getElementById('sliderRotSpeed');

const MONTH_DAYS = [0,31,59,90,120,151,181,212,243,273,304,334,365];
const MONTH_NAMES = ['1월','2월','3월','4월','5월','6월','7월','8월','9월','10월','11월','12월'];
function dayToDate(d) {
  d = ((d % 365) + 365) % 365;
  for (let m = 0; m < 12; m++) {
    if (d < MONTH_DAYS[m + 1]) {
      return `${MONTH_NAMES[m]} ${d - MONTH_DAYS[m] + 1}일`;
    }
  }
  return '12월 31일';
}

function togglePlay() {
  playing = !playing;
  document.getElementById('btnPlay').textContent = playing ? '⏸ 일시정지' : '▶ 재생';
  document.getElementById('btnPlay').classList.toggle('active', playing);
}

// Mouse tracking for wind info
let mouseMapLat = null, mouseMapLon = null;
document.getElementById('cvMap').addEventListener('mousemove', function(e) {
  const rect = this.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  mouseMapLon = (x / rect.width) * 360 - 180;
  mouseMapLat = 90 - (y / rect.height) * 180;
});
document.getElementById('cvMap').addEventListener('mouseleave', function() {
  mouseMapLat = null;
  mouseMapLon = null;
});

function animate(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = Math.min(50, timestamp - lastTime) / 1000;
  lastTime = timestamp;

  const orbSpeed = parseFloat(elSliderOrbSpeed.value);
  const rotSpeed = parseFloat(elSliderRotSpeed.value);
  const obliquity = parseFloat(elSliderObl.value);
  const ecc = parseFloat(elSliderEcc.value);

  if (playing) {
    orbitalAngle += dt * orbSpeed * 0.15;
    if (orbitalAngle > Math.PI * 2) orbitalAngle -= Math.PI * 2;
    rotLon += dt * rotSpeed * 15;
    if (rotLon > 360) rotLon -= 360;
  }

  // Compute day of year from orbital angle
  let dayOfYear = ((orbitalAngle + Math.PI / 2) / (2 * Math.PI)) * 365;
  dayOfYear = ((dayOfYear % 365) + 365) % 365;
  elSliderDay.value = Math.round(dayOfYear);

  // Update display values
  document.getElementById('dispDay').textContent = dayToDate(dayOfYear);
  document.getElementById('dispObl').textContent = obliquity.toFixed(1) + '°';
  document.getElementById('dispEcc').textContent = ecc.toFixed(3);
  document.getElementById('dispOrbSpeed').textContent = orbSpeed.toFixed(1) + 'x';
  document.getElementById('dispRotSpeed').textContent = rotSpeed.toFixed(1) + 'x';

  // Wind info at mouse position
  if (mouseMapLat !== null) {
    const w = getWind(mouseMapLat, mouseMapLon, dayOfYear, obliquity);
    const speed = Math.sqrt(w.u ** 2 + w.v ** 2);
    const dir = ((Math.atan2(-w.u, -w.v) * 180 / Math.PI) + 360) % 360;
    document.getElementById('dispWind').textContent =
      `${mouseMapLat.toFixed(0)}°${mouseMapLat>=0?'N':'S'} ${Math.abs(mouseMapLon).toFixed(0)}°${mouseMapLon>=0?'E':'W'} | ${speed.toFixed(1)} m/s`;
  } else {
    document.getElementById('dispWind').textContent = '지도 위에 마우스를 올리세요';
  }

  // Update particles
  updateParticles(dayOfYear, obliquity, dt * 4);

  // Render
  const { ctx: ctxOrb, w: wO, h: hO } = setupCanvas(document.getElementById('cvOrbit'));
  renderOrbital(ctxOrb, wO, hO, orbitalAngle, ecc, obliquity, dayOfYear);

  const { ctx: ctxGlobe, w: wG, h: hG } = setupCanvas(document.getElementById('cvGlobe'));
  renderGlobe(ctxGlobe, wG, hG, rotLon, obliquity, dayOfYear);

  const { ctx: ctxMap, w: wM, h: hM } = setupCanvas(document.getElementById('cvMap'));
  renderMap(ctxMap, wM, hM, dayOfYear, obliquity);

  requestAnimationFrame(animate);
}

// Slider interactions
elSliderDay.addEventListener('input', () => {
  const day = parseInt(elSliderDay.value);
  orbitalAngle = (day / 365) * 2 * Math.PI - Math.PI / 2;
  if (playing) togglePlay();
});
elSliderObl.addEventListener('input', () => {
  mapTexture = null; // force re-render
});

// Init
buildLandMask();
initParticles();
requestAnimationFrame(animate);
</script>
<footer style="text-align:center;padding:10px;color:#3a4a6a;font-size:.8em;border-top:1px solid #1a2a4a;">
  지구 시뮬레이션 — Earth Simulation Project
<br>Built with <a href="https://claude.ai/claude-code" style="color:#5af;text-decoration:none">Claude Code</a> (Anthropic Claude Opus 4.6)
</footer>
</body>
</html>
